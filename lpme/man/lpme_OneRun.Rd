% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lpme_DoOneRun.R
\name{lpme_onerun}
\alias{lpme_onerun}
\title{lpme_onerun}
\usage{
lpme_onerun(
  Y,
  observables,
  observables_groupings = colnames(observables),
  make_observables_groupings = FALSE,
  estimation_method = "emIRT",
  ordinal = FALSE,
  conda_env = "lpme",
  conda_env_required = TRUE,
  seed = NULL
)
}
\arguments{
\item{Y}{A vector of observed outcome variables}

\item{observables}{A matrix of observable indicators used to estimate the latent variable}

\item{observables_groupings}{A vector specifying groupings for the observable indicators. Default is column names of observables.}

\item{make_observables_groupings}{Logical. If TRUE, creates dummy variables for each level of the observable indicators. Default is FALSE.}

\item{estimation_method}{Character specifying the estimation approach. Options include:
\itemize{
\item "emIRT" (default): Uses expectation-maximization via \code{emIRT} package. Supports both binary (via \code{emIRT::binIRT}) and ordinal (via \code{emIRT::ordIRT}) indicators.
\item "MCMC": Basic Markov Chain Monte Carlo estimation using either \code{pscl::ideal} (R backend) or \code{numpyro} (Python backend)
\item "MCMCFull": Full Bayesian model that simultaneously estimates latent variables and outcome relationship using \code{numpyro}
\item "MCMCOverImputation": Two-stage MCMC approach with measurement error correction via over-imputation
}}

\item{ordinal}{Logical indicating whether the observable indicators are ordinal (TRUE) or binary (FALSE).}

\item{conda_env}{A character string specifying the name of the conda environment to use 
via \code{reticulate}. Default is \code{"lpme"}.}

\item{conda_env_required}{A logical indicating whether the specified conda environment 
must be strictly used. If \code{TRUE}, an error is thrown if the environment is not found. 
Default is \code{TRUE}.}

\item{seed}{Random seed for reproducibility. Default is a random integer between 1 and 10000 (used internally)}
}
\value{
A list containing various estimates and statistics:
\itemize{
  \item \code{ols_coef}: Coefficient from naive OLS regression
  \item \code{ols_se}: Standard error of naive OLS coefficient
  \item \code{ols_tstat}: T-statistic of naive OLS coefficient
  \item \code{corrected_ols_coef}: OLS coefficient corrected for measurement error
  \item \code{corrected_ols_se}: Standard error of corrected OLS coefficient (currently NA)
  \item \code{corrected_ols_tstat}: T-statistic of corrected OLS coefficient (currently NA)
  \item \code{corrected_ols_coef_alt}: Alternative corrected OLS coefficient (currently NA)
  \item \code{iv_coef}: Coefficient from instrumental variable regression
  \item \code{iv_se}: Standard error of IV regression coefficient
  \item \code{iv_tstat}: T-statistic of IV regression coefficient
  \item \code{corrected_iv_coef}: IV regression coefficient corrected for measurement error
  \item \code{corrected_iv_se}: Standard error of corrected IV coefficient
  \item \code{corrected_iv_tstat}: T-statistic of corrected IV coefficient
  \item \code{var_est_split}: Estimated variance of the measurement error
  \item \code{x_est1}: First set of latent variable estimates
  \item \code{x_est2}: Second set of latent variable estimates
}
}
\description{
Implements analysis for latent variable models with measurement error correction
}
\details{
This function implements a latent variable analysis with measurement error correction. 
It splits the observable indicators into two sets, estimates latent variables using each set, 
and then applies various correction methods including OLS correction and instrumental variable approaches.
}
\examples{
# Generate some example data
set.seed(123)
Y <- rnorm(100)
observables <- as.data.frame( matrix(sample(c(0,1), 1000*10, replacement = TRUE), ncol = 10) )

# Run the analysis
results <- lpme_onerun(Y, observables)

# View the corrected OLS coefficient
print(results$Corrected_OLSCoef)

}


R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "lpmec"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "lpmec-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('lpmec')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("KnowledgeVoteDuty")
> ### * KnowledgeVoteDuty
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: KnowledgeVoteDuty
> ### Title: KnowledgeVoteDuty: Survey Respondents' Views of Voting as a Duty
> ###   and Political Knowledge Questions
> ### Aliases: KnowledgeVoteDuty
> 
> ### ** Examples
> 
> data(KnowledgeVoteDuty)
> voteduty <- KnowledgeVoteDuty$voteduty
> knowledge <- scale(rowMeans(KnowledgeVoteDuty[ , -1]))
> summary(lm(voteduty ~ knowledge))

Call:
lm(formula = voteduty ~ knowledge)

Residuals:
    Min      1Q  Median      3Q     Max 
-4.2859 -2.5608  0.7141  2.0766  3.1642 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  4.49624    0.04362 103.066   <2e-16 ***
knowledge    0.41936    0.04363   9.611   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 2.413 on 3057 degrees of freedom
Multiple R-squared:  0.02933,	Adjusted R-squared:  0.02901 
F-statistic: 92.38 on 1 and 3057 DF,  p-value: < 2.2e-16

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("KnowledgeVoteDuty", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("build_backend")
> ### * build_backend
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: build_backend
> ### Title: A function to build the environment for lpmec. Builds a conda
> ###   environment in which 'JAX', 'numpyro', and 'numpy' are installed.
> ###   Users can also create a conda environment where 'JAX' and 'numpy' are
> ###   installed themselves.
> ### Aliases: build_backend
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Create a conda environment named "lpmec"
> ##D # and install the required Python packages (jax, numpy, etc.)
> ##D build_backend(conda_env = "lpmec", conda = "auto")
> ##D 
> ##D # If you want to specify a particular conda path:
> ##D # build_backend(conda_env = "lpmec", conda = "/usr/local/bin/conda")
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("build_backend", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("infer_orientation_signs")
> ### * infer_orientation_signs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: infer_orientation_signs
> ### Title: Infer orientation signs for each observable indicator
> ### Aliases: infer_orientation_signs
> 
> ### ** Examples
> 
> set.seed(1)
> Y <- rnorm(10)
> obs <- data.frame(matrix(sample(c(0,1), 20, replace = TRUE), ncol = 2))
> infer_orientation_signs(Y, obs)
[1] -1  1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("infer_orientation_signs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lpmec")
> ### * lpmec
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lpmec
> ### Title: lpmec
> ### Aliases: lpmec
> 
> ### ** Examples
> 
> ## No test: 
> # Generate some example data
> set.seed(123)
> Y <- rnorm(1000)
> observables <- as.data.frame(matrix(sample(c(0,1), 1000*10, replace = TRUE), ncol = 10))
> 
> # Run the bootstrapped analysis
> results <- lpmec(Y = Y,
+                  observables = observables,
+                  n_boot = 10,    # small values for illustration only
+                  n_partition = 5 # small for size
+                  )
{booti_ 1 of 11} -- {parti_ 1 of 5}
{booti_ 1 of 11} -- {parti_ 2 of 5}
{booti_ 1 of 11} -- {parti_ 3 of 5}
{booti_ 1 of 11} -- {parti_ 4 of 5}
{booti_ 1 of 11} -- {parti_ 5 of 5}
{booti_ 2 of 11} -- {parti_ 1 of 5}
{booti_ 2 of 11} -- {parti_ 2 of 5}
{booti_ 2 of 11} -- {parti_ 3 of 5}
{booti_ 2 of 11} -- {parti_ 4 of 5}
{booti_ 2 of 11} -- {parti_ 5 of 5}
{booti_ 3 of 11} -- {parti_ 1 of 5}
{booti_ 3 of 11} -- {parti_ 2 of 5}
{booti_ 3 of 11} -- {parti_ 3 of 5}
{booti_ 3 of 11} -- {parti_ 4 of 5}
{booti_ 3 of 11} -- {parti_ 5 of 5}
{booti_ 4 of 11} -- {parti_ 1 of 5}
{booti_ 4 of 11} -- {parti_ 2 of 5}
{booti_ 4 of 11} -- {parti_ 3 of 5}
{booti_ 4 of 11} -- {parti_ 4 of 5}
{booti_ 4 of 11} -- {parti_ 5 of 5}
{booti_ 5 of 11} -- {parti_ 1 of 5}
{booti_ 5 of 11} -- {parti_ 2 of 5}
{booti_ 5 of 11} -- {parti_ 3 of 5}
{booti_ 5 of 11} -- {parti_ 4 of 5}
{booti_ 5 of 11} -- {parti_ 5 of 5}
{booti_ 6 of 11} -- {parti_ 1 of 5}
{booti_ 6 of 11} -- {parti_ 2 of 5}
{booti_ 6 of 11} -- {parti_ 3 of 5}
{booti_ 6 of 11} -- {parti_ 4 of 5}
{booti_ 6 of 11} -- {parti_ 5 of 5}
{booti_ 7 of 11} -- {parti_ 1 of 5}
{booti_ 7 of 11} -- {parti_ 2 of 5}
{booti_ 7 of 11} -- {parti_ 3 of 5}
{booti_ 7 of 11} -- {parti_ 4 of 5}
{booti_ 7 of 11} -- {parti_ 5 of 5}
{booti_ 8 of 11} -- {parti_ 1 of 5}
{booti_ 8 of 11} -- {parti_ 2 of 5}
{booti_ 8 of 11} -- {parti_ 3 of 5}
{booti_ 8 of 11} -- {parti_ 4 of 5}
{booti_ 8 of 11} -- {parti_ 5 of 5}
{booti_ 9 of 11} -- {parti_ 1 of 5}
{booti_ 9 of 11} -- {parti_ 2 of 5}
{booti_ 9 of 11} -- {parti_ 3 of 5}
{booti_ 9 of 11} -- {parti_ 4 of 5}
{booti_ 9 of 11} -- {parti_ 5 of 5}
{booti_ 10 of 11} -- {parti_ 1 of 5}
{booti_ 10 of 11} -- {parti_ 2 of 5}
{booti_ 10 of 11} -- {parti_ 3 of 5}
{booti_ 10 of 11} -- {parti_ 4 of 5}
{booti_ 10 of 11} -- {parti_ 5 of 5}
{booti_ 11 of 11} -- {parti_ 1 of 5}
{booti_ 11 of 11} -- {parti_ 2 of 5}
{booti_ 11 of 11} -- {parti_ 3 of 5}
{booti_ 11 of 11} -- {parti_ 4 of 5}
{booti_ 11 of 11} -- {parti_ 5 of 5}
> 
> # View the corrected IV coefficient and its standard error
> print(results)
Latent Predictor Measurement Error Correction (LPMEC) Model Results
-------------------------------------------------------------------
Uncorrected Coefficient (OLS): -0.006 (SE: 0.035)
Corrected Coefficient: -0.010 (SE: 0.136)
Bayesian OLS (Outer): NA (SE: NA)
Use summary() for detailed results.
> ## End(No test)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lpmec", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lpmec_onerun")
> ### * lpmec_onerun
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lpmec_onerun
> ### Title: lpmec_onerun
> ### Aliases: lpmec_onerun
> 
> ### ** Examples
> 
> ## No test: 
> # Generate some example data
> set.seed(123)
> Y <- rnorm(1000)
> observables <- as.data.frame(matrix(sample(c(0,1), 1000*10, replace = TRUE), ncol = 10))
> 
> # Run the analysis
> results <- lpmec_onerun(Y = Y,
+                         observables = observables)
> 
> # View the corrected estimates
> print(results)
Single-Run LPMEC Results
------------------------
Uncorrected Coefficient (OLS): -0.004 (SE: 0.031)
Corrected Coefficient: 0.015 (SE: NA)
Use summary() for detailed results.
> ## End(No test)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lpmec_onerun", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  12.257 0.142 12.415 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
